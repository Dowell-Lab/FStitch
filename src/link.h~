/*
 * link.h
 *
 *  Created on: Jan 25, 2014
 *      Author: joeyazo
 */
#include <vector>
#include <string>
#include <iostream>
#include <fstream>
#include "split.h"
#include "MEMM_class.h"
#include <algorithm>
#include <time.h>
#include "readInRefGene.h"
using namespace std;
#ifndef LINK_H_
#define LINK_H_

double maximum(vector<double> array){
	double * curr_max = NULL;
	for (int i =0; i<array.size(); i++){
		if (curr_max == NULL){
			curr_max = &array[i];
		}
		else if (*curr_max < array[i]){
			curr_max = &array[i];
		}
	}
	return *curr_max;
}

double sample_variance(vector<double> array, double mean){
	double sum = 0;
	for (int i =0; i < array.size(); i++){
		sum = sum + pow((array[i] - mean),2);
	}
	return (sum / (float)array.size());
}



void linkFile(string fileName, string input_strand, string refGeneFileName,string linkedFileName, bool write_linked, bool SHOW = 1){
	clock_t time;
	int f;
	time = clock();


	ifstream myfile(fileName);
	tree * refGeneStructure = new tree();
	refGeneStructure  = readRefGene(refGeneFileName);

	if (refGeneStructure->strand_ptr != NULL){
		if (myfile.is_open()){
			string line, chrom;
			string token;
			int start, stop, coverage;
			int prev = 0;
			vector<string> lineInfo;
			int pos;
			int query_pos;
			//=======================================
			//	Binary File Handle
			//=======================================
			string BinfileName = linkedFileName;
			string rplc = ".dat";
			ofstream writeFileHandleBinary;
			writeFileHandleBinary.open(BinfileName, ios::binary);
			string TextFileName = replace(BinfileName, rplc, ".bed");
			ofstream TestFileHandle;
			if (write_linked){
				//=======================================
				//	Text File Handle
				//=======================================
				TestFileHandle.open(TextFileName);
			}

			double sum;
			int cov;
			int N;
			vector<double> coverages;
			string GENE_ID;
			string length;
			string begin_chrom="";
			int begin = 0;
			double mean;
			string out_line;
			MEMM MEMM_obj;
			while ( getline(myfile,line) ){
				lineInfo	= split(line, "\t");
				//===========================================================//
				//	Index of lineInfo					  					 //
				//	0 = chromosome						  					 //
				// 	1 = start							  					 //
				//	2 = stop							  					 //
				//	3 = coverage across span			  					 //
				// 	Search = refGeneStructure, strand, chromosome, query_pos //
				//===========================================================//
				if (lineInfo.size() != 4){
				  cout<<lineInfo.size()<<endl;
				}
				start = atoi(lineInfo[1].c_str());
				stop = atoi(lineInfo[2].c_str());
				if (begin_chrom != lineInfo[0] and SHOW){
					cout<<"Linking..."<< lineInfo[0]<<endl;
				}

				if (prev){
					if (prev != start or begin_chrom != lineInfo[0]){
						query_pos = (prev + begin) / 2;
						GENE_ID = search(refGeneStructure, input_strand, lineInfo[0], query_pos);
						if (GENE_ID.empty()){
							GENE_ID = "N/A";
						}

						length = to_string(static_cast <long long> (prev - begin));

						if (write_linked){
							//==================================================
							//	Writing to linked data to text file for
							//	other programs (python...) to interpret and parse
							//	This Linked data is the continuous segment with
							//	no interruptions in read connection
							//==================================================
							out_line = begin_chrom + "\t" +  to_string(static_cast <long long> (begin)) + "\t" + to_string(static_cast <long long>  (prev)) + "\t" + length + "\t" + GENE_ID + "\t\n";
							TestFileHandle<<out_line;
						}


						mean = (float)sum / (float)N;

						MEMM_obj = MEMM(input_strand , begin_chrom, begin, prev,  GENE_ID, (prev - begin), mean , maximum(coverages), sample_variance(coverages,mean));

						//==================================================
						//	Writing to Binary File for faster processing...
						writeFileHandleBinary.write((char*)&MEMM_obj, sizeof(MEMM_obj));

						sum	= 0;
						N 	= 0;


						length = to_string(static_cast <long long> ((start - prev) * -1));

						coverages.clear();
						if (write_linked){
							//==================================================
							//	Writing to linked data to text file for
							//	other programs (python...) to interpret and parse
							//	This is gap between when a continuous segment of
							// 	reads end and the next segment beings
							//	signified by the fact that its a negative length
							//==================================================
							out_line = lineInfo[0] + "\t" + to_string(static_cast <long long> (prev)) + "\t" + to_string(static_cast <long long>  (start)) + "\t" + length + "\t" + GENE_ID + "\t0\n";
							TestFileHandle<<out_line;

						}

						MEMM_obj = MEMM(input_strand , begin_chrom, prev, start,  GENE_ID,((start - prev) * -1),0,0,0);
						//==================================================
						//	Writing to Binary File for faster processing...
						writeFileHandleBinary.write((char*)&MEMM_obj, sizeof(MEMM_obj));
					     
						begin = start;
						begin_chrom = lineInfo[0];
					}
				}
				else{
					begin = start;
					begin_chrom = lineInfo[0];
				}
				prev = stop;

				N++;
				cov = atof(lineInfo[3].c_str());
				sum = sum+cov;
				coverages.push_back(cov);
				lineInfo.clear();
			}
			refGeneStructure->clear(refGeneStructure);
			writeFileHandleBinary.close();
		}
		else
		{
			cout<<"Unable to open bed graph file: "<<fileName<<"...try specifying full path/spelling error correction"<<endl;
		}

	}

	cout<<"...linked bed graph file:\t"<<((float)clock()-time)/CLOCKS_PER_SEC<<" seconds..."<<endl;
}

#endif /* LINK_H_ */
